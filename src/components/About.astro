---
import settings from "../data/home.json"

const { heroVideo = settings.heroVideo, story = settings.aboutText } = Astro.props
---

<div class="immerse-section-tr js-immerse-section-tr">
	<!-- Sticky container -->
	<div class="immerse-section-tr__media js-immerse-section-tr__media">
		<!-- Mobile Video -->
		<figure class="immerse-section-tr__figure immerse-section-tr__figure--3-4 md:hidden js-immerse-section-tr__figure">
			<video src={heroVideo} autoplay loop muted playsinline></video>
		</figure>

		<!-- Desktop Video -->
		<figure class="immerse-section-tr__figure immerse-section-tr__figure--16-9 hidden md:block js-immerse-section-tr__figure">
			<video src={heroVideo} autoplay loop muted playsinline></video>
		</figure>
	</div>

	<!-- ABOUT CONTENT (wrapped in max-width container) -->
	<section class="immerse-section-tr__content py-12 bg-slate-900 lg:py-20 mt-8 lg:mt-12 js-immerse-section-tr__content">
		<div class="container px-4 mx-auto py-20">
			<!--About Content -->
			<div class="flex flex-wrap -m-8">
				<div class="w-full md:w-1/2 p-8">
					<div class="md:max-w-md">
						<h2 class="font-headings font-bold text-red-400 mb-8 text-6xl uppercase">Our Story</h2>
						<p class="font-body text-gray-400 font-medium">
							{story}
						</p>
					</div>
				</div>
				<div class="w-full md:w-1/2 p-8">
					<div class="flex flex-wrap -m-6">
						<div class="w-full md:w-1/2 p-6">
							<div class="max-w-xs text-left md:mx-auto">
								<h6 class="font-headings mb-3 text-xl font-bold text-red-400">State-of-the-Art Equipment</h6>
								<p class="text-sm text-gray-400 font-medium">Harness cutting-edge technology to create professional-grade content.</p>
							</div>
						</div>
						<div class="w-full md:w-1/2 p-6">
							<div class="max-w-xs text-left md:mx-auto">
								<h6 class="font-headings mb-3 text-xl font-bold text-red-400">Tailored Services</h6>
								<p class="text-sm text-gray-400 font-medium">From pre-production to post-production, we cater to your unique needs.</p>
							</div>
						</div>
						<div class="w-full md:w-1/2 p-6">
							<div class="max-w-xs text-left md:mx-auto">
								<h6 class="font-headings mb-3 text-xl font-bold text-red-400">Passionate Team</h6>
								<p class="text-sm text-gray-400 font-medium">Work with a community of creatives committed to bringing visions to life.</p>
							</div>
						</div>
						<div class="w-full md:w-1/2 p-6">
							<div class="max-w-xs text-left md:mx-auto">
								<h6 class="font-headings mb-3 text-xl font-bold text-red-400">Diverse Portfolio</h6>
								<p class="text-sm text-gray-400 font-medium">Explore our wide range of successful projects across various genres.</p>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
	</section>
</div>

<!--Style-->
<style>
	.immerse-section-tr {
		position: relative;
		--immerse-section-tr-opacity: 0;
	}
	.immerse-section-tr__media {
		position: -webkit-sticky;
		position: sticky;
		top: 0;
		z-index: 1;
		overflow: hidden;
		pointer-events: none;
	}
	.immerse-section-tr--disabled .immerse-section-tr__media {
		position: relative;
	}
	.immerse-section-tr__figure {
		will-change: transform;
		pointer-events: auto;
		position: relative;
		height: 0;
		transition: transform 0.3s ease-out;
	}
	.immerse-section-tr__figure > * {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		object-fit: cover;
	}
	.immerse-section-tr__figure--16-9 {
		padding-bottom: 40%;
	}
	.immerse-section-tr__figure--3-4 {
		padding-bottom: 133.33%;
	}
	.immerse-section-tr__content {
		position: relative;
		z-index: 3;
		transform: translateZ(0);
	}
	.immerse-section-tr__content::after,
	.immerse-section-tr__content::before {
		content: "";
		pointer-events: none;
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		opacity: var(--immerse-section-tr-opacity, 0);
		pointer-events: none;
	}
	.immerse-section-tr__content::before {
		height: 100%;
		z-index: -1;
	}
	.immerse-section-tr__content::after {
		height: 100vh;
		transform: translateY(-100%);
	}
	.immerse-section-tr--disabled .immerse-section-tr__content::before {
		opacity: 1;
	}
	.text-bg-fx {
		background-repeat: no-repeat;
		will-change: background-size;
		transition: background-size 0.3s cubic-bezier(0.645, 0.045, 0.355, 1);
	}
	.text-bg-fx:hover {
		background-size: 100% 100%;
	}

	.text-bg-fx--scale-x {
		padding-top: 0.125rem; /* py-0.5 */
		padding-bottom: 0.125rem; /* py-0.5 */
		padding-left: 0; /* px-0 */
		padding-right: 0; /* px-0 */
		background-image: linear-gradient(hsla(245 58% 51% / 0.2), hsla(245 58% 51% / 0.2));
		background-size: 0% 100%;
	}

	@media (min-width: 1024px) {
		.text-bg-fx--scale-x {
			padding-top: 0.25rem; /* lg:py-1 */
			padding-bottom: 0.25rem; /* lg:py-1 */
		}
	}

	.text-bg-fx--scale-y {
		text-decoration: none;
		background-image: linear-gradient(hsla(245 58% 51% / 0.2), hsla(245 58% 51% / 0.2));
		background-size: 100% 2px;
		background-position: center bottom;
	}

	.text-bg-fx--underline,
	.text-bg-fx--underline-bold {
		text-decoration: none;
		background-size: 0% 100%;
	}

	.text-bg-fx--underline {
		/* text underline size = 1px */
		background-image: linear-gradient(transparent calc(100% - 3px), currentColor calc(100% - 3px), currentColor calc(100% - 2px), transparent 2px);
	}

	.text-bg-fx--underline-bold {
		background-image: linear-gradient(transparent 50%, hsla(245 58% 51% / 0.2) 50%);
	}

	.text-bg-fx--text-shadow {
		/* you can use this with the .text-bg-fx--underline effect */
		text-shadow:
			1.5px 1px hsl(0, 0%, 100%),
			-1.5px 1px hsl(0, 0%, 100%),
			0px 1px hsl(0, 0%, 100%);
	}
</style>

<!-- Script -->
<script>
	class Util {
		static addClass(el: HTMLElement, className: string): void {
			const classList = className.split(" ")
			el.classList.add(classList[0])
			if (classList.length > 1) {
				Util.addClass(el, classList.slice(1).join(" "))
			}
		}

		static removeClass(el: HTMLElement, className: string): void {
			const classList = className.split(" ")
			el.classList.remove(classList[0])
			if (classList.length > 1) {
				Util.removeClass(el, classList.slice(1).join(" "))
			}
		}

		static osHasReducedMotion(): boolean {
			if (!window.matchMedia) return false
			const matchMediaObj = window.matchMedia("(prefers-reduced-motion: reduce)")
			return matchMediaObj ? matchMediaObj.matches : false
		}
	}

	class ImmerseSection {
		element: HTMLElement
		media: HTMLElement[]
		scrollContent: HTMLElement[]
		figure: HTMLElement[]
		visibleFigure: HTMLElement | false = false
		mediaScale = 1
		mediaInitHeight = 0
		elementPadding = 0
		scrollingFn: (() => void) | false = false
		scrolling = false
		active = false
		scrollDelta = 0

		constructor(element: HTMLElement) {
			this.element = element
			this.media = Array.from(element.getElementsByClassName("js-immerse-section-tr__media") as HTMLCollectionOf<HTMLElement>)
			this.scrollContent = Array.from(element.getElementsByClassName("js-immerse-section-tr__content") as HTMLCollectionOf<HTMLElement>)
			this.figure = this.media.length > 0 ? Array.from(this.media[0].getElementsByClassName("js-immerse-section-tr__figure") as HTMLCollectionOf<HTMLElement>) : []
			if (this.media.length < 1 || this.figure.length < 1) return

			this.init()
		}

		private init(): void {
			this.initContainer()
			this.resetSection()
			this.element.addEventListener("update-immerse-section", () => this.resetSection())

			const observer = new IntersectionObserver(this.intersectionCallback.bind(this))
			observer.observe(this.media[0])
		}

		private initContainer(): void {
			if (parseInt(window.getComputedStyle(this.element).getPropertyValue("padding-top")) === 0) {
				this.element.style.paddingTop = "1px"
			}
		}

		private resetSection(): void {
			this.getVisibleFigure()
			this.checkEffectActive()
			if (this.active) {
				Util.removeClass(this.element, "immerse-section-tr--disabled")
				this.updateMediaHeight()
				this.getMediaScale()
				this.updateMargin()
				this.updateScaleAndOpacity()
			} else {
				Util.addClass(this.element, "immerse-section-tr--disabled")
				this.media[0].style.cssText = ""
				if (this.scrollContent[0]) {
					this.scrollContent[0].style.cssText = ""
				}
				this.updateScale(1)
				this.updateOpacity(0)
			}

			this.element.dispatchEvent(
				new CustomEvent("immersive-section-updated", {
					detail: { active: this.active, asset: this.visibleFigure },
				})
			)
		}

		private getVisibleFigure(): void {
			this.visibleFigure = this.figure.find((fig) => window.getComputedStyle(fig).getPropertyValue("display") !== "none") || false
		}

		private updateMediaHeight(): void {
			if (!this.visibleFigure) return

			this.mediaInitHeight = this.visibleFigure.offsetHeight
			this.scrollDelta = 600

			this.media[0].style.height = `${window.innerHeight}px`
			this.media[0].style.paddingTop = `${(window.innerHeight - this.visibleFigure.offsetHeight) / 2}px`
			this.media[0].style.marginTop = `${(this.visibleFigure.offsetHeight - window.innerHeight) / 2}px`
		}

		private getMediaScale(): void {
			if (!this.visibleFigure) return

			const scaleX = this.roundValue(window.innerWidth / this.visibleFigure.offsetWidth)
			const scaleY = this.roundValue(window.innerHeight / this.visibleFigure.offsetHeight)

			this.mediaScale = Math.max(scaleX, scaleY)
			this.elementPadding = parseInt(window.getComputedStyle(this.element).getPropertyValue("padding-top"))
		}

		private roundValue(value: number): number {
			return parseFloat((Math.ceil(value * 100) / 100).toFixed(2))
		}

		private updateMargin(): void {
			if (this.scrollContent.length > 0) {
				this.scrollContent[0].style.marginTop = `${this.scrollDelta}px`
			}
		}

		private updateScaleAndOpacity(): void {
			if (!this.active) return

			const offsetTop = (window.innerHeight - this.mediaInitHeight) / 2
			const top = this.element.getBoundingClientRect().top + this.elementPadding

			if (top < offsetTop && top > offsetTop - this.scrollDelta) {
				const scale = 1 + ((top - offsetTop) * (1 - this.mediaScale)) / this.scrollDelta
				this.updateScale(scale)
				this.updateOpacity(0)
			} else if (top >= offsetTop) {
				this.updateScale(1)
				this.updateOpacity(0)
			} else {
				this.updateScale(this.mediaScale)
				this.updateOpacity((1.2 * (offsetTop - this.scrollDelta - top)) / window.innerHeight)
			}

			this.scrolling = false
		}

		private updateScale(value: number): void {
			if (!this.visibleFigure) return
			this.visibleFigure.style.transform = `scale(${value})`
		}

		private updateOpacity(value: number): void {
			this.element.style.setProperty("--immerse-section-tr-opacity", value.toString())
		}

		private intersectionCallback(entries: IntersectionObserverEntry[]): void {
			if (entries[0].isIntersecting) {
				if (!this.scrollingFn) {
					this.scrollingFn = this.handleScroll.bind(this)
					window.addEventListener("scroll", this.scrollingFn as EventListener)
				}
			} else {
				if (this.scrollingFn) {
					window.removeEventListener("scroll", this.scrollingFn)
					this.scrollingFn = false
				}
			}
		}

		/**private handleScroll(): void {
			if (this.scrolling) return
			this.scrolling = true
			window.requestAnimationFrame(() => this.updateScaleAndOpacity())
		}>**/
		private handleScroll(): void {
			window.requestAnimationFrame(() => this.updateScaleAndOpacity())
		}

		private checkEffectActive(): void {
			this.active = !!this.visibleFigure && this.visibleFigure.offsetHeight < window.innerHeight && window.innerHeight - this.visibleFigure.offsetHeight < 600
		}
	}
	// Initialize ImmerseSection instances
	function initializeImmerseSections(): void {
		const immerseSections = document.getElementsByClassName("js-immerse-section-tr") as HTMLCollectionOf<HTMLElement>
		const reducedMotion = Util.osHasReducedMotion()
		const supportsIntersectionObserver = "IntersectionObserver" in window

		if (immerseSections.length < 1 || reducedMotion || !supportsIntersectionObserver) {
			Array.from(immerseSections).forEach((el) => Util.addClass(el, "immerse-section-tr--disabled"))
			return
		}

		const sections = Array.from(immerseSections).map((el) => new ImmerseSection(el))

		let resizeTimeout: ReturnType<typeof setTimeout>
		window.addEventListener("resize", () => {
			clearTimeout(resizeTimeout)
			resizeTimeout = setTimeout(() => {
				sections.forEach((section) => {
					section.element.dispatchEvent(new CustomEvent("update-immerse-section"))
				})
			}, 500)
		})
	}

	initializeImmerseSections()
</script>
